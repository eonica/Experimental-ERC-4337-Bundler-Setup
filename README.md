# Experimental-ERC-4337-Bundler-Setup
Experimental setup for ERC-4337 Environment Tests used in ISEEE 2025 paper evaluation of ERC-4337 Bundler Power Consumption

This is a guide for setting up an experimental playground for testing an ERC-4337 bundler.
It was used for monitoring a bundler for its power consumption in measurements conducted for the work in [An Introductory Study on the Power Consumption Overhead of ERC-4337 Bundlers](https://arxiv.org/abs/2511.16890) ISEEE 2025 paper. 
It simulates a feed of ERC-4337 UserOps for transfering ERC-20 tokens between some sets of addresses, via a Bundler and all the ERC-4337 infrastructure. 

It uses mainly the following tools, which require installation/setup (some indications below):

- (Optional) [Blockscout](https://github.com/blockscout/blockscout) blockchain explorer for monitoring the blocks of processed UserOps
- [Anvil (from the Foundry package)](https://github.com/foundry-rs/foundry?tab=readme-ov-file) as blockchain backend simulator
- [Alto (Pimlico)](https://github.com/pimlicolabs/alto) as the tested ERC-4337 bundler
- [SmartWatts](https://powerapi.org/reference/formulas/smartwatts/) for the power consumption measurements

## (Optional) Configuration of Blockscout

Blockscout would normally require setting the configurations for *anvil* and *chain id* options, in order to monitor the simulated Anvil chain. These are normally found in the *anvil.yml*, *docker-compose.yml*, *env/common-blockscout.env* files in the Blockscout installation. 
The options can normally be set as:
`ETHEREUM_JSONRPC_VARIANT=anvil`
`CHAIN_ID=1`

Blockscout should be further started together with Anvil, for monitoring the produced blocks. It is recommended to start it before Anvil and stop it after stopping Anvil to avoid desyncing issues. This is typically done via docker compose (start and stop):
`docker-compose -f anvil.yml up -d`
`docker-compose down -v`
Note that use of Blockscout is optional altogether.

## Running Anvil

To run Anvil as the blockchain simulator, after installing a typical command is as follows (with persistent state storage):
`anvil --port 8545 --host 0.0.0.0 --chain-id 1337 --block-time 15 --gas-limit 30000000 --gas-price 1 --load-state my_state.json --dump-state my_state.json --code-size-limit 0x1000000`

Parameters can be adjusted upon need. Note that that --load-state expects a state file and should be ommitted at first run. 

## Deploying necessary contracts

Running an ERC-4337 environment in a private playground needs the deployment of an ERC-4337 EntryPoint contract and of a factory for smart accounts creation on the local simulated chain. The 0.6 versions of the above contracts can be loaded in Remix via the *EPLoader.sol* file provided in this repo. These can be compiled and deployed to the Anvil network. Note that further minor adjustment in the sources might be needed in order to acccomodate changes with newer versions, depending on the compiler used.  

An ERC-20 token contract, the provided *TestToken.sol*, should also be deployed as final destination for the transactions generated from the UserOps feed. 

After these deployments, a number of smart account contracts (SCAs) nshould be created to act as the UserOps validators and proxys further to the *TestToken.sol*. These should also be funded to act as sponsors for the transactions. 
A test account address from the set generated by Anvil, is pre-allocated with test Ether, and can create, own and use in parallel multiple SCAs, as long as for each configures a different salt.
A bash script that does this for the first 10 owner test accounts from Anvil is given in *createAccounts* on this repository. 
Usage is by providing the salt and Ether to transfer (optional), e.g.:
`createAccounts 0x0A 1ether`
The created SCAs are dumped in a file saved using the naming scheme *created_accounts_salt_${SALT}.txt*. These should be further included in the UserOps feeding script. 

## Runing Alto

The Alto bundler requires adjusting its configuration in *alto-config.json* to match the address of the deployed EntryPoint contract and set some sponsor address private keys for funding from the Anvil generated addressed. A typical configuration looks like this:
`{
    "entrypoints": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "executor-private-keys": "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80,0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
    "utility-private-key": "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    "rpc-url": "http://localhost:8545",
    "safe-mode": false
}`

Running Alto afterwards can be done by:
`./alto run --config "alto-config.json" --port 3000`

## Running the UserOps feed

The UserOps feed can be run using the *transferUserOpRoundsThrottled.ts* script. 
This should be transpiled first to .js (both current versions provided on repo), using: 
`npx tsc -p ./tsconfig.json`

The script has various hardcoded parameters that can or should be configured, like:

- the Anvil and Alto RPC addresses (typically shouldn't change)
- the address of the EntryPoint contract (typically shouldn't change)
- the number and addresses of the SCAs
- the number and addresses of the funding accounts, generated by Anvil (typically fixed)
- the destination ERC-20 token address
- the throttle time per round of messages
- the total number of rounds

To finally run the script, simply:
`node transferUserOpRoundsThrottled.js`

## Monitoring Power Consumption via SmartWatts

First, check if your system is compatible with the RAPL sensor requirements stated on the SmartWatts/PowerAPI kit website.
Then, be sure to have the PowerAPI/SmartWatts kit installed. In particular, the following are probably necessary:
`docker pull ghcr.io/powerapi-ng/hwpc-sensor
sudo /usr/bin/python3 -m pip install "powerapi[hwpc,csv]"
sudo modprobe msr`

Monitoring the power consumption requires two steps:

1. Getting the raw RAPL power measurements
2. Computing the SmartWatts accurately estimated actual power consumption per process

For 1) the monitoring options are set in a *config_file.json*, like the metrics monitored, desired sampling, interval and others, which are described on the PowerAPI page. 
Then, the monitoring can be started using a command line as follows (pay attention to the docked mapping paths, this will place results in a *sensor_output* folder that should exist in the local directory):

`docker run --rm  --net=host --privileged --pid=host -v /sys:/sys -v /var/lib/docker/containers:/var/lib/docker/containers:ro -v $(pwd)/sensor_output:/tmp/sensor_output -v $(pwd):/srv -v $(pwd)/config_file.json:/config_file.json powerapi/hwpc-sensor --config-file /config_file.json`

In order to capture the monitored consumption per process, the target processes should be run in transient scope units leveraging cgroups separation. These should be normally part of the user.slice. You can check information on their cgroups association using: 
`systemd-cgls
ls /sys/fs/cgroup`

And to effectively run in transient scoped mode: 
`systemd-run --scope --slice=user.slice --unit=anvil anvil --port 8545 --host 0.0.0.0 --chain-id 1337 --block-time 15 --gas-limit 45000000 --gas-price 1 --load-state my_state.json --dump-state my_state.json --code-size-limit 50000000 --silent

systemd-run --scope --slice=user.slice --unit=alto ./alto run --config "alto-config.json" --port 3000`

After the 1) monitoring is done, 2) is just a matter of computing the final results based on the gathered data. This can be executed in the folder where the measurements were stored with (the outputs will be stored in a *swatts* folder): 

`python3 -m smartwatts \
--input csv --model HWPCReport --files core.csv,msr.csv,rapl.csv --name puller_csv \
--output csv --model PowerReport --directory $(pwd)/swatts/ --name pusher_csv  \
--cpu-base-freq 2200 \
--cpu-tdp 45 \
--cpu-error-threshold 2.0 \
--disable-dram-formula \
--sensor-reports-frequency 500`

**Note** that the setup above might still require fixes for the numerous configuration needed.

### Acknowledgement
This work was supported by a grant from the Romanian Ministry of Research, Innovation and Digitization, CNCS/CCCDI - UEFISCDI, project number 86/2025 ERANET-CHISTERA-IV-SCEAL, within PNCDI IV.

